import { Platform, Alert } from 'react-native';
// @ts-ignore - No types available for this library
import RNFS from 'react-native-fs';
// @ts-ignore - No types available for this library
import RNHTMLtoPDF from 'react-native-html-to-pdf';
import { saveDocuments } from '@react-native-documents/picker';
import Share from 'react-native-share';
import Clipboard from '@react-native-clipboard/clipboard';
import type { Note } from '../types';

export interface ExportOptions {
  fileName?: string;
  includeMetadata?: boolean;
}

/**
 * Create a temporary file in app's cache directory
 */
const createTempFile = async (fileName: string, content: string | Uint8Array, encoding: 'utf8' | 'base64' = 'utf8'): Promise<string> => {
  const tempDir = RNFS.CachesDirectoryPath;
  const tempFilePath = `${tempDir}/${fileName}`;
  
  if (typeof content === 'string') {
    await RNFS.writeFile(tempFilePath, content, encoding);
  } else {
    // Convert Uint8Array to base64 string
    const base64Content = Buffer.from(content).toString('base64');
    await RNFS.writeFile(tempFilePath, base64Content, 'base64');
  }
  
  return tempFilePath;
};

/**
 * Export a note to PDF format with modern "Save As" dialog
 */
export const exportNoteToPDF = async (note: Note, options: ExportOptions = {}): Promise<string | null> => {
  try {
    const fileName = options.fileName || `${note.title || 'Untitled'}_${Date.now()}.pdf`;
    
    // Create HTML content
    const htmlContent = `
      <!DOCTYPE html>
      <html>
        <head>
          <meta charset="utf-8">
          <title>${note.title || 'Untitled Note'}</title>
          <style>
            body {
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
              line-height: 1.6;
              color: #333;
              max-width: 800px;
              margin: 0 auto;
              padding: 20px;
            }
            .header {
              border-bottom: 2px solid #007AFF;
              padding-bottom: 20px;
              margin-bottom: 30px;
            }
            .title {
              font-size: 28px;
              font-weight: bold;
              color: #007AFF;
              margin-bottom: 10px;
            }
            .metadata {
              font-size: 14px;
              color: #666;
              margin-bottom: 5px;
            }
            .content {
              font-size: 16px;
              line-height: 1.8;
              white-space: pre-wrap;
            }
            .footer {
              margin-top: 40px;
              padding-top: 20px;
              border-top: 1px solid #eee;
              font-size: 12px;
              color: #999;
              text-align: center;
            }
          </style>
        </head>
        <body>
          <div class="header">
            <h1 class="title">${note.title || 'Untitled Note'}</h1>
            ${options.includeMetadata ? `
              <div class="metadata">Created: ${note.createdAt ? new Date(note.createdAt).toLocaleDateString() : 'Unknown'}</div>
              <div class="metadata">Last Updated: ${note.updatedAt ? new Date(note.updatedAt).toLocaleDateString() : 'Unknown'}</div>
              <div class="metadata">Tone: ${note.tone || 'Unknown'}</div>
              ${note.tags && note.tags.length > 0 ? `<div class="metadata">Tags: ${note.tags.join(', ')}</div>` : ''}
            ` : ''}
          </div>
          <div class="content">${note.plainText || 'No content available'}</div>
          <div class="footer">
            Generated by NoteSpark AI • ${new Date().toLocaleDateString()}
          </div>
        </body>
      </html>
    `;

    // Generate PDF to temporary location
    const tempFileName = `temp_${Date.now()}_${fileName}`;
    const options_pdf = {
      html: htmlContent,
      fileName: tempFileName.replace('.pdf', ''),
      directory: RNFS.CachesDirectoryPath,
      width: 612,
      height: 792,
      padding: 40,
    };

    const pdf = await RNHTMLtoPDF.convert(options_pdf);
    
    if (!pdf.filePath) {
      throw new Error('Failed to generate PDF');
    }

    // Use modern "Save As" dialog to let user choose save location
    const [result] = await saveDocuments({
      sourceUris: [`file://${pdf.filePath}`],
      fileName: fileName,
      mimeType: 'application/pdf',
    });
    
    // Clean up temporary file
    await RNFS.unlink(pdf.filePath).catch(() => {});
    
    if (result.error) {
      throw new Error(result.error);
    }
    
    Alert.alert(
      'PDF Saved Successfully!',
      `Your PDF has been saved as "${result.name}" to the location you selected.`,
      [{ text: 'OK' }]
    );
    
    return result.uri;
  } catch (error: any) {
    console.error('Error exporting to PDF:', error);
    
    // Handle user cancellation gracefully
    if (error.code === 'DOCUMENT_PICKER_CANCELED') {
      return null; // User cancelled, don't show error
    }
    
    Alert.alert('Export Error', 'Failed to export note to PDF. Please try again.');
    return null;
  }
};

/**
 * Export a note to RTF format (Word-compatible) with modern "Save As" dialog
 */
export const exportNoteToDocx = async (note: Note, options: ExportOptions = {}): Promise<string | null> => {
  try {
    const baseFileName = options.fileName || `${note.title || 'Untitled'}_${Date.now()}`;
    const rtfFileName = baseFileName.replace(/\.(docx|doc)$/i, '') + '.rtf';
    
    // Create RTF content (Rich Text Format - opens in Word)
    let rtfContent = '{\\rtf1\\ansi\\deff0 {\\fonttbl {\\f0 Times New Roman;}}';
    rtfContent += '{\\colortbl;\\red0\\green0\\blue0;\\red0\\green122\\blue255;}';
    rtfContent += '\\f0\\fs28';
    
    // Title
    rtfContent += `{\\b\\fs32\\cf2 ${note.title || 'Untitled Note'}}\\par\\par`;
    
    // Metadata
    if (options.includeMetadata) {
      rtfContent += `{\\i Created: ${note.createdAt ? new Date(note.createdAt).toLocaleDateString() : 'Unknown'}}\\par`;
      rtfContent += `{\\i Last Updated: ${note.updatedAt ? new Date(note.updatedAt).toLocaleDateString() : 'Unknown'}}\\par`;
      rtfContent += `{\\i Tone: ${note.tone || 'Unknown'}}\\par`;
      if (note.tags && note.tags.length > 0) {
        rtfContent += `{\\i Tags: ${note.tags.join(', ')}}\\par`;
      }
      rtfContent += '\\par';
    }
    
    // Content
    const content = note.plainText || 'No content available';
    const contentLines = content.split('\n');
    contentLines.forEach(line => {
      // Escape special RTF characters
      const escapedLine = line.replace(/[{}\\]/g, '\\$&');
      rtfContent += `${escapedLine}\\par`;
    });
    
    rtfContent += '\\par{\\i\\fs20 Generated by NoteSpark AI}';
    rtfContent += '}';

    // Create temporary file
    const tempFilePath = await createTempFile(rtfFileName, rtfContent, 'utf8');

    // Use modern "Save As" dialog
    const [result] = await saveDocuments({
      sourceUris: [`file://${tempFilePath}`],
      fileName: rtfFileName,
      mimeType: 'application/rtf',
    });

    // Clean up temporary file
    await RNFS.unlink(tempFilePath).catch(() => {});

    if (result.error) {
      throw new Error(result.error);
    }

    Alert.alert(
      'Document Saved Successfully!',
      `Your document has been saved as "${result.name}" to the location you selected.\n\nThis RTF file can be opened in Microsoft Word and other word processors.`,
      [{ text: 'OK' }]
    );

    return result.uri;
  } catch (error: any) {
    console.error('Error exporting to RTF:', error);
    
    // Handle user cancellation gracefully
    if (error.code === 'DOCUMENT_PICKER_CANCELED') {
      return null; // User cancelled, don't show error
    }
    
    Alert.alert('Export Error', 'Failed to export note to document. Please try again.');
    return null;
  }
};

/**
 * Export a note to text format with modern "Save As" dialog
 */
export const exportNoteToText = async (note: Note, options: ExportOptions = {}): Promise<string | null> => {
  try {
    const fileName = options.fileName || `${note.title || 'Untitled'}_${Date.now()}.txt`;
    
    // Create text content
    let textContent = `${note.title || 'Untitled Note'}\n`;
    textContent += '='.repeat(50) + '\n\n';
    
    if (options.includeMetadata) {
      textContent += `Created: ${note.createdAt ? new Date(note.createdAt).toLocaleDateString() : 'Unknown'}\n`;
      textContent += `Last Updated: ${note.updatedAt ? new Date(note.updatedAt).toLocaleDateString() : 'Unknown'}\n`;
      textContent += `Tone: ${note.tone || 'Unknown'}\n`;
      if (note.tags && note.tags.length > 0) {
        textContent += `Tags: ${note.tags.join(', ')}\n`;
      }
      textContent += '\n';
    }
    
    textContent += 'Content:\n';
    textContent += '-'.repeat(20) + '\n';
    textContent += note.plainText || 'No content available';
    textContent += '\n\n' + '-'.repeat(50);
    textContent += '\nGenerated by NoteSpark AI';
    textContent += `\n${new Date().toLocaleDateString()}`;

    // Create temporary file
    const tempFilePath = await createTempFile(fileName, textContent, 'utf8');

    // Use modern "Save As" dialog
    const [result] = await saveDocuments({
      sourceUris: [`file://${tempFilePath}`],
      fileName: fileName,
      mimeType: 'text/plain',
    });

    // Clean up temporary file
    await RNFS.unlink(tempFilePath).catch(() => {});

    if (result.error) {
      throw new Error(result.error);
    }

    Alert.alert(
      'Text File Saved Successfully!',
      `Your text file has been saved as "${result.name}" to the location you selected.`,
      [{ text: 'OK' }]
    );

    return result.uri;
  } catch (error: any) {
    console.error('Error exporting to text:', error);
    
    // Handle user cancellation gracefully
    if (error.code === 'DOCUMENT_PICKER_CANCELED') {
      return null; // User cancelled, don't show error
    }
    
    Alert.alert('Export Error', 'Failed to export note to text file. Please try again.');
    return null;
  }
};

/**
 * Share a note using the system share sheet
 */
export const shareNote = async (note: Note, options: ExportOptions = {}): Promise<void> => {
  try {
    let shareContent = '';
    
    // Build share content
    shareContent += `${note.title || 'Untitled Note'}\n`;
    shareContent += '━'.repeat(40) + '\n\n';
    
    if (options.includeMetadata) {
      shareContent += `📅 Created: ${note.createdAt ? new Date(note.createdAt).toLocaleDateString() : 'Unknown'}\n`;
      shareContent += `🔄 Updated: ${note.updatedAt ? new Date(note.updatedAt).toLocaleDateString() : 'Unknown'}\n`;
      shareContent += `🎭 Tone: ${note.tone || 'Unknown'}\n`;
      if (note.tags && note.tags.length > 0) {
        shareContent += `🏷️ Tags: ${note.tags.join(', ')}\n`;
      }
      shareContent += '\n';
    }
    
    shareContent += note.plainText || 'No content available';
    shareContent += '\n\n━'.repeat(40);
    shareContent += '\n📱 Shared from NoteSpark AI';

    const shareOptions = {
      title: `Share "${note.title || 'Untitled Note'}"`,
      message: shareContent,
      subject: note.title || 'Note from NoteSpark AI',
    };

    await Share.open(shareOptions);
  } catch (error: any) {
    if (error.message !== 'User did not share') {
      console.error('Error sharing note:', error);
      Alert.alert('Share Error', 'Failed to share note. Please try again.');
    }
  }
};

/**
 * Copy note content to clipboard
 */
export const copyNoteToClipboard = async (note: Note, options: ExportOptions = {}): Promise<void> => {
  try {
    let clipboardContent = '';
    
    if (options.includeMetadata) {
      clipboardContent += `${note.title || 'Untitled Note'}\n`;
      clipboardContent += `Created: ${note.createdAt ? new Date(note.createdAt).toLocaleDateString() : 'Unknown'}\n`;
      clipboardContent += `Updated: ${note.updatedAt ? new Date(note.updatedAt).toLocaleDateString() : 'Unknown'}\n`;
      clipboardContent += `Tone: ${note.tone || 'Unknown'}\n`;
      if (note.tags && note.tags.length > 0) {
        clipboardContent += `Tags: ${note.tags.join(', ')}\n`;
      }
      clipboardContent += '\n';
    }
    
    clipboardContent += note.plainText || 'No content available';
    
    Clipboard.setString(clipboardContent);
    Alert.alert('Copied!', 'Note content has been copied to clipboard.');
  } catch (error) {
    console.error('Error copying to clipboard:', error);
    Alert.alert('Copy Error', 'Failed to copy note content. Please try again.');
  }
};
